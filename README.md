# Concurrency-Porgramming #

---

*Java并发编程实战、Java并发编程的艺术、Java多线程编程核心技术中的主要知识点和代码实现*


## java并发机制底层 ##

+ volatile : 轻量级的synchronized

>多处理器开发中保证了<font color="red">共享变量</font>的`可见性`,即当一个线程改变一个共享变量时，其他的线程也能读取到这个修改的值
>java内存模型确保所有线程看到的这个变量的值是一直的

可见性保证：Lock前缀指令、缓存一致性

优化：追加字节优化性能

+ synchronized
>synchronized用的锁存于java对象头中的 *Mark Word* 区域中
>jdk1.6以后，引入了**偏向锁**和**轻量级锁**来减少获取锁和释放锁的性能消耗  
>锁四种状态：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，状态可以升级但不可降级

+ 原子操作
**CAS:** Compare And Swap 
>CAS操作需要输入两个值，一个旧值(期望操作前)、一个新值，操作时先比较旧值是否变化，无则交换程新值，有则不操作

**java实现原子操作：** 循环CAS

循环CAS问题：
>ABA问题 ---> 使用版本号解决  
>循环时间长开销大  
>只能保证一个共享变量的原子操作  ---> 多个变量需要锁来实现  

## java内存模型  ##

+ 相关基本概念
>1. 通信：线程间以何种机制来交换信息，其机制主要有两种：共享内存和消息传递
>共享内存：线程间共享程序的公共状态，通过读-写内存中的公共状态**隐式**通信
>消息传递：线程间无的共享公共状态，只能**显式**通过消息传递来通信
>2. 同步： 程序中用于控制不同线程间操作大声相对顺序的机制
>共享内存：显式（加锁机制）
>消息传递：隐式

**<font color="red">小结：</font>** java中并发采用*共享内存模型*，通信是*隐式*进行的

+ 内存模型抽象结构
JMM(Java内存模型)决定了一个线程对*共享变量的操作*何时对另一个线程可见，其抽象模型如下：
![Java内存模型](https://github.com/RecYan/Concurrency-Porgramming/raw/master/img/ch3-1.jpg)  

即线程A与线程B通信过程如下：
>线程A将本地内存A中更新过的共享变量刷新到主内存中
>线程B再主内存中去读取该共享变量

**<font color="red">注意：</font>**
1. 本地内存为JMM的抽象概念，并不真实存在
2. JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java来提供内存可见性保证
---

## **Java多线程核心知识点** ##
1. 进程：一次程序的运行，为系统进行资源分配和调度的一个独立单位 eg->任务列表中的exe文件  
2. 线程：进程中独立运行的子任务  
3. 多线程编程实现方式：i.继承Thread类 ii.实现Runnable接口  
> 需要注意：`public class Thread implements Runnable`，Thread类实现了Runnable接口  
4. 在JVM中，i++的执行过程：  
>1. 取得原有i值  
>2. 计算i+1  
>3. 对i进行复制  
>4. **若有多线程访问时，很容易出现线程不安全问题，需要引起注意**  
5. API常见方法：  
>currentThread(): 返回代码段正在被那个线程调用  
>isAlive(): 判断当前线程是否处于活动状态  
>sleep(): 在指定毫秒内让当前“正在执行的线程”休眠  
>getId(): 取得线程的唯一标志  
6. 线程停止问题  
> interrupted(): 测试**当前线程**是否终端，仅仅在当前线程搭了一个停止的标记，并不是真正的通知线程,其具有清除状态的功能  
``` java
/*** public static boolean interrupted ***/  
Thread.currentThread.interrupted();  
System.out.println(Thread.interrupted()); //true  
System.out.println(Thread.interrupted()); //false  
```
> isInterrupted()：测试Thread对象是否已经停止，但不清楚状态标志
``` java
/*** public boolean interrupted ***/  
Thread.currentThread.interrupted();  
System.out.println(Thread.isInterrupted()); //true  
System.out.println(Thread.isInterrupted()); //true  
```
7. 线程暂停问题
>suspend(): 暂停线程， resume(): 恢复线程运行  
>**注意：**可能出现*独占锁*的现象，不同步现象  
>yield(): 放弃当前cpu的执行权  
8. 线程优先级：java中线程优先级分为1--10个等级，等级越高，优先级越大  
9. 守护线程： 但进程中不存在非守护线程时，该线程自动销毁，典型的例子就是 *垃圾回收线程*  

**同步相关**
1. 非线程安全： 多个线程对同一个对象中的实例变量进行并发访问时发生，可能会出现*脏读*
2. 方法内的变量时线程安全的 --> 见HasSelfPrivateNum.java
3. 

---

# Java并发编程与高并发解决方案 #
## 并发基础 ##
1. 并发：多个线程同时操作相同的资源，保证线程安全性，合理使用资源
2. 高并打：服务能够同时处理多个请求，提高程序性能
3. cpu多级缓存: cpu -> catch -> menory
4. 缓存一致性（MESI）: 保证多个cpu catch之间缓存共享数据的一致性
> M: Modified 修改，指的是该缓存行只被缓存在该CPU的缓存中，并且是被修改过的，因此他与主存中的数据是不一致的，该缓存行中的数据需要在未来的某个时间点（允许其他CPU读取主存相应中的内容之前）写回主存，然后状态变成E（独享）  
>E：Exclusive 独享 缓存行只被缓存在该CPU的缓存中，是未被修改过的，与主存的数据是一致的，可以在任何时刻当有其他CPU读取该内存时，变成S（共享）状态，当CPU修改该缓存行的内容时，变成M（被修改）的状态  
>S：Share 共享，意味着该缓存行可能会被多个CPU进行缓存，并且该缓存中的数据与主存数据是一致的，当有一个CPU修改该缓存行时，其他CPU是可以被作废的，变成I(无效的)  
>I：Invalid 无效的，代表这个缓存是无效的，可能是有其他CPU修改了该缓存行  
>**M(Modified)和E(Exclusive)状态的Cache line，数据是独有的，不同点在于M状态的数据是dirty的(和内存的不一致)，E状态的数据是clean的(和内存的一致)。**
5. 乱序执行优化：cpu为了提高运算速度而做出违背代码原有顺序的优化,可能导致逻辑上后写入的数据不一定最后写入
6. java内存模型（JMM）: 规定了一个线程如何和何时可以看到其他线程修改过后的共享变量的值,如何以及何时同步的访问共享变量
7. JMM中八种同步操作：
>1. Lock（锁定）：作用于主内存的变量，把一个变量标识变为一条线程独占状态
>2. Unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
>3. Read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
>4. Load（载入）：作用于**工作内存**的变量，它把Read操作从主内存中得到的变量值放入**工作内存的变量副本**中
>5. Use（使用）：作用于**工作内存**的变量，把**工作内存中的一个变量值传递给执行引擎**
>6. Assign（赋值）：作用于**工作内存**的变量，它**把一个从执行引擎接受到的值赋值给工作内存的变量**
>7. Store（存储）：作用于**工作内存**的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作
>8. Write（写入）：作用于主内存的变量，它把Store操作从工作内存中一个变量的值传送到主内存的变量中

![同步方法](https://i.imgur.com/cXLguBk.jpg)
8. JMM同步规则：
>1. 如果要把一个变量从主内存中赋值到工作内存，就需要按顺序得执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序得执行store和write操作，但java内存模型只要求上述操作必须按顺序执行，没有保证必须是连续执行,也就是说Read和Load、Store和Write之间是可以插入其他指令的
>2. 不允许read和load、store和write操作之一单独出现
>3. 不允许一个线程丢弃他的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中
>4. 不允许一个线程无原因地（也就是说必须有assgin操作）把数据从工作内存同步到主内存中
>5. 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了load和assign操作
>6. 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以同时被一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会解锁，lock和unlock必须成对出现
>7. 如果一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎中使用这个变量前需要重新执行load或assign操作初始化变量的值
>8. 如果一个变量事先没有被lock操作锁定，则不允许他执行unlock操作，也不允许去unlock一个被其他线程锁定的变量
>9. 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（其实就是执行store和write操作之后）

## 测试项目搭建 ##
1. 使用 Spring-Boot 项目做简单测试用例 <concurrency>  
2. 模拟工具： Postman、Apache Bench(AB)、JMeter、代码并发模拟：Semaphore, CountDownLatch  

**CountDownLatch示意图**: 即阻塞线程 且在特定的条件下执行指定的线程  
![CountDownLatch](https://i.imgur.com/mzQUNWf.jpg)  
**SemaPhore示意图**：信号量，阻塞线程 并控制统一时间内的并发请求量  
![SemaPhore](https://i.imgur.com/MAd7KET.jpg)  